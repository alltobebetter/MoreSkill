# 数据库事务与锁

## 什么是事务

事务就是"要么全做，要么全不做"的一组操作。

经典例子：转账。A 给 B 转 100 元：
1. A 的余额减 100
2. B 的余额加 100

如果第 1 步成功、第 2 步失败，钱就凭空消失了。事务保证这两步要么都成功，要么都回滚。

## ACID 特性

| 特性 | 含义 | 比喻 |
|------|------|------|
| 原子性（Atomicity） | 全做或全不做 | 要么全吃，要么全不吃 |
| 一致性（Consistency） | 数据始终合法 | 转账前后总金额不变 |
| 隔离性（Isolation） | 事务之间互不干扰 | 各做各的，互不影响 |
| 持久性（Durability） | 提交后数据不丢 | 写入就是写入，断电也在 |

## 事务的使用

```sql
BEGIN;  -- 开始事务

UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;

COMMIT;  -- 提交（全部生效）
-- 或者
ROLLBACK;  -- 回滚（全部撤销）
```

## 隔离级别

| 级别 | 脏读 | 不可重复读 | 幻读 | 性能 |
|------|------|-----------|------|------|
| 读未提交 | 可能 | 可能 | 可能 | 最好 |
| 读已提交 | 不会 | 可能 | 可能 | 好 |
| 可重复读 | 不会 | 不会 | 可能 | 一般 |
| 串行化 | 不会 | 不会 | 不会 | 最差 |

MySQL 默认是"可重复读"，PostgreSQL 默认是"读已提交"。

## 锁

### 乐观锁 vs 悲观锁

| | 乐观锁 | 悲观锁 |
|---|--------|--------|
| 思路 | 假设不会冲突，提交时检查 | 假设会冲突，先锁再操作 |
| 实现 | 版本号 / 时间戳 | SELECT FOR UPDATE |
| 适合 | 读多写少 | 写多冲突多 |

```sql
-- 乐观锁：用版本号
UPDATE products SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 5;
-- 如果 version 不是 5，说明被别人改过了，更新失败

-- 悲观锁：锁住这行
SELECT * FROM products WHERE id = 1 FOR UPDATE;
-- 其他事务要等这个事务结束才能操作这行
```

## 死锁

两个事务互相等待对方释放锁，谁也无法继续。

```
事务A：锁住行1，等待行2
事务B：锁住行2，等待行1
→ 死锁
```

数据库会自动检测死锁并回滚其中一个事务。预防方法：按固定顺序访问资源。

> 事务和锁是数据一致性的基石，理解它们才能写出可靠的后端代码。
